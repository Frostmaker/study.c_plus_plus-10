/*
1. Функция должна определять отношение среднего арифметического элементов массива до первого нуля к среднему арифметическому элементов после первого нуля.
2. Функция построения таблицы значений произвольной функции на отрезке. 
    Табулируемая функция должна передаваться как параметр и
    может быть не определена в некоторых точках отрезка табуляции. 
    Табулируемая функция, должна выбрасывать исключение, а функция построения
    таблицы в таких точках выдавать "значение функции не определено" и
    продолжать строить таблицу для остальных точек.
3. Функция вычисления значения выражения, вводимого в формате:

        цифра знак операции цифра

4. Дополнить функцию ввода динамического массив проверкой,
    что динамический массив еще не размещен в памяти.
*/

#include <iostream>
#include "defs.h"
#include <string>
#include "windows.h"

using namespace std;


void menu()
{
    cout << "/======================= MENU =======================\\\n";
    cout << "| 1. Отношение средних арифметических                |\n";
    cout << "| 2. Построение таблицы ln(x) на промежутке          |\n";
    cout << "| 3. Вычисления значения выражения                   |\n";
    cout << "| 4. Создание динамических массивов                  |\n";
    cout << "| 5. Очистка динамических массивов                   |\n";
    cout << "| 6. Вывод меню                                      |\n";
    cout << "| 7. Выход                                           |\n";
    cout << "\\====================================================/\n";
}


int main()
{
    setlocale(LC_ALL, "Rus");
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    menu();
    int p;
    bool ext{ true };
    int* ar = nullptr;
    int* ar2 = nullptr;
    int size, size2;
    while (ext)
    {
        cout << "\nВыберите пункт меню: ";
        cin >> p; cout << "\n";

        switch (p)
        {

        case 1: {
            int zero_pos;
            bool checkpoint{ true };
            while (checkpoint) {
                cout << "Введите размер массива — ";
                cin >> size;
                if (size < 3)
                    cout << "В массиве необходимо хотя бы 3 числа!" << endl;
                else
                    checkpoint = false;
            }

            checkpoint = true;
            delete[] ar;
            ar = new int[size];
            for (int i{ 0 }; i < size; i++) {
                cout << "Введите " << i + 1 << " элемент массива — ";
                cin >> ar[i];
                if (ar[i] == 0 && checkpoint) {
                    zero_pos = i;
                    checkpoint = false;
                }
            }

            if (checkpoint)
                cout << "В массиве нету нулей!";
            else {
                try
                {
                    cout << "\nОтвет — " << ratio(ar, size, zero_pos) << endl;
                }
                #pragma region Обработки ошибок
                catch (int err)
                {
                    switch (err) {
                    case -2:
                        cout << "Ошибка: после 0 вводились только нули. В итоге: деление на 0\n";
                        break;
                    case -3:
                        cout << "Ошибка: после или перед первым 0 нету цифр\n";
                        break;
                    }
                }
                #pragma endregion
            }
            break;  
        }

        case 2: {
            cout << "Введите крайние значения промежутка через пробел: ";
            double a, b;
            cin >> a >> b;
            if (a > b)
                swap(a, b);
            print_func(my_ln, a, b);
            break;
        }

        case 3: {
            cout << "Введите выражение: ";
            int a, b;
            char s;
            cin >> a >> s >> b;
            try
            {
                cout << my_solve(a, b, s);
            }
            #pragma region Обработки ошибок
            catch (int err)
            {
                switch (err) {
                case -2:
                    cout << "Ошибка: деление на 0\n";
                    break;
                case -4:
                    cout << "Ошибка: неверный арифметический оператор\n";
                    break;
                }
            }
            #pragma endregion
            break;
        }

        case 4: {
            // Массив, который использовался в первом пункте
            cout << "\nПервый массив (из пункта 1)\n";
            /*
            Есть небольшой костыль: функция read() нужна для создания массива,
            однако именно в этой лабе, чтобы проверять существование массива.
            Создание массива уже включено в 1 пункт.
            Из-за этого, если сначала НЕ создать массив в 1 пункте, т. е.
            вызвать 5 пункт перед вызовом 1, Вам придётся создавать этот массив
            здесь. А когда вы зайдете в 1 пункт, вы по новой будете создавать массив.

            Решение простое: сначала делаем 1 пункт, потом 5, видим что "первый" массив
            уже существует, а "второй" нужно создать. Profit! (⌐■_■)
            */
            try
            {
                read(ar, size);
            }
            #pragma region Обработки ошибок
            catch (int err)
            {
                cout << "Ошибка: динамический массив уже существует\n";
            }
            #pragma endregion

            // Массив, которого нету в памяти
            cout << "\nВторой массив\n";       
            try
            {
                read(ar2, size2);
            }
            #pragma region Обработки ошибок
            catch (int err)
            {
                cout << "Ошибка: динамический массив уже существует\n";
            }
            #pragma endregion
            break;
        }

        case 5: {
            delete[] ar, ar2;
            ar = nullptr;
            ar2 = nullptr;
            break;
        }

        case 6: {
            menu();
            break;
        }

        case 7: {
            ext = false;
            delete[] ar, ar2;
            ar = nullptr;
            ar2 = nullptr;
            break;
        }

        default: {
            cout << "Неверный пункт меню!";
            break;
        }

        }

    }

    //system("pause");
    return 0;
}